---
date:  2022-12-20
title: 抽象工厂模式
tags: 
categories:
---


## 什么是抽象工厂模式
抽象工厂模式是一种软件设计模式，它提供了一种方法来创建相关或依赖对象的组合，而不需要指定它们的具体类。

这种模式把对象的创建延迟到子类，使得子类可以决定实例化哪些类。这样，程序可以在运行时动态地改变它所使用的对象，而不需要修改代码。

抽象工厂模式通常由以下几个部分组成：

-   抽象工厂（Abstract Factory）：它是工厂模式的核心，是与应用程序无关的。它声明了用于创建一组相关或相互依赖对象的接口，每个接口方法对应一个产品。
    
-   具体工厂（Concrete Factory）：它实现了在抽象工厂中声明的创建产品的方法。
    
-   抽象产品（Abstract Product）：它是工厂模式所创建的对象的父类，封装了所有它的共性。
    
-   具体产品（Concrete Product）：它是继承自抽象产品的具体类，实现了在抽象产品中声明的抽象方法。

## 例1
```ts
interface Animal {
  makeSound(): void;
}

class Dog implements Animal {
  makeSound() {
    console.log('Bark');
  }
}

class Cat implements Animal {
  makeSound() {
    console.log('Meow');
  }
}

interface AnimalFactory {
  createAnimal(): Animal;
}

class DogFactory implements AnimalFactory {
  createAnimal() {
    return new Dog();
  }
}

class CatFactory implements AnimalFactory {
  createAnimal() {
    return new Cat();
  }
}

// 用法
const dogFactory = new DogFactory();
const dog = dogFactory.createAnimal();
dog.makeSound(); // Bark

const catFactory = new CatFactory();
const cat = catFactory.createAnimal();
cat.makeSound(); // Meow
```

在这个例子中，我们有 `Animal` 接口和两个实现它的类 `Dog` 和 `Cat`。我们还有一个 `AnimalFactory` 接口和两个实现它的类 `DogFactory` 和 `CatFactory`，这些类分别生成 `Dog` 和 `Cat` 对象。

然后我们可以使用工厂类来创建新的动物对象，而无需直接使用具体的类名。这使得我们可以在不改变客户端代码的情况下更改动物类的实现。

## 例2
假设你正在开发一个用于制作披萨的应用程序。披萨的制作需要许多不同的原料，包括面团、酱料、蔬菜和肉类。你可以使用抽象工厂模式来创建用于制作这些原料的工厂。

例如，你可以创建一个抽象工厂接口 `PizzaIngredientFactory`，其中定义了用于创建各种原料的方法，如 `createDough()`、`createSauce()`、`createVeggies()` 和 `createMeat()`。然后，你可以创建一个具体工厂类，如 `NYPizzaIngredientFactory` 和 `ChicagoPizzaIngredientFactory`，它们实现了 `PizzaIngredientFactory` 接口并具体提供了如何创建原料的方法。

然后，你可以使用这些工厂来创建不同类型的披萨，如芝士披萨或辣香肠披萨。每种披萨都可以使用特定工厂的方法来创建所需的原料，而无需关心它们是如何制作的。

下面是 typescript 代码实例：
首先，你可以创建一个抽象工厂接口，如下所示：
```ts
interface PizzaIngredientFactory {
  createDough(): Dough;
  createSauce(): Sauce;
  createVeggies(): Veggies[];
  createMeat(): Meat;
}
```

然后，你可以创建一个具体工厂类，如下所示：
```ts
class NYPizzaIngredientFactory implements PizzaIngredientFactory {
  createDough(): Dough {
    // Return a thin crust dough
  }
  createSauce(): Sauce {
    // Return a marinara sauce
  }
  createVeggies(): Veggies[] {
    // Return an array of vegetables
  }
  createMeat(): Meat {
    // Return sausage as the meat
  }
}
```

最后，你可以使用这些工厂来创建披萨对象，如下所示：
```ts
```
##  抽象工厂模式和工厂方法模式的关系
抽象工厂模式提供了一种方法来创建一组相关的产品对象，而工厂方法模式提供了一种方法来创建单个产品对象。

在工厂方法模式中，有多个具体的工厂类来生成不同的产品对象。如果这些具体的工厂类之间有相同的部分，那么我们可以将这些相同的部分封装到一个抽象工厂类中，具体的工厂类继承抽象工厂类，实现生成产品对象的方法。

这样就可以将工厂方法模式进一步抽象成抽象工厂模式。在抽象工厂模式中，抽象工厂负责声明创建一组相关的产品对象的方法，具体的工厂负责生成具体的产品对象。

总的来说，抽象工厂模式是在工厂方法模式的基础上进一步抽象的一种设计模式，它提供了一种方法来创建一组相关的产品对象。