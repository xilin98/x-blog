
---
date:  2022-12-20
title: 工厂方法模式
tags: 
categories:
---
工厂方法模式是一种设计模式，它提供了一种方法来创建对象，而无需指定构造函数的类型。 在工厂方法模式中，使用一个专门的工厂类来创建所需的对象。 在抽象工厂类中定义了一个抽象工厂方法，该方法返回一个抽象产品类型。 具体工厂类继承抽象工厂类，并实现抽象工厂方法。 这样，在具体工厂类中就可以创建具体的产品对象。

## 例1
举个例子，假设我们有一个抽象产品类型为 `Shape`，并有两个具体产品，即 `Circle` 和 `Square`。 如果我们使用工厂方法模式来创建这些产品，那么我们可能会定义如下代码：

```js
// 抽象产品类
abstract class Shape {
  abstract draw(): void;
}

// 具体产品类 1
class Circle extends Shape {
  draw() {
    // 实现画圆的逻辑
  }
}

// 具体产品类 2
class Square extends Shape {
  draw() {
    // 实现画正方形的逻辑
  }
}

// 抽象工厂类
abstract class ShapeFactory {
  abstract createShape(): Shape;
}

// 具体工厂类 1
class CircleFactory extends ShapeFactory {
  createShape(): Shape {
    return new Circle();
  }
}

// 具体工厂类 2
class SquareFactory extends ShapeFactory {
  createShape(): Shape {
    return new Square();
  }
}

```

工厂方法模式是一种非常有用的设计模式，它可以让我们在不指定构造函数的类型的情况下创建对象。 它可以使代码更加灵活，并且可以轻松地更改或扩展应用程序的对象创建方式。

实际上，也就是说，工厂方法不直接使用构造函数，而是使用一个工厂类，这个工厂类是和构造函数解耦。
这样，我们就可以在不指定具体的构造函数类型的情况下创建对象。 这使得代码更加灵活，并且可以轻松地更改或扩展应用程序的对象创建方式。

## 例子2
假设我们正在开发一个游戏，其中玩家可以使用多种武器进行战斗。 我们可以使用工厂方法模式来实现这个功能。

首先，我们可以定义一个抽象产品类型 `Weapon`，其中包含了武器的抽象方法 `use()`。 我们还可以定义几个具体产品类型，如 `Sword` 和 `Bow`，它们分别代表剑和弓。 接下来，我们可以定义一个抽象工厂类型 `WeaponFactory`，其中包含了一个抽象工厂方法 `createWeapon()`，该方法返回一个 `Weapon` 类型的对象。 最后，我们可以定义两个具体工厂类型，如 `SwordFactory` 和 `BowFactory`，它们分别继承了 `WeaponFactory` 类型，并实现了 `createWeapon()` 方法。

首先，我们定义抽象产品类型 Weapon：
```ts
abstract class Weapon {
  abstract use(): void;
}
```

然后，我们定义具体产品类型 Sword 和 Bow：
```ts
class Sword extends Weapon {
  use() {
    console.log("Swinging sword!");
  }
}

class Bow extends Weapon {
  use() {
    console.log("Shooting arrow!");
  }
}
```

接下来，我们定义抽象工厂类型 WeaponFactory：

```ts
abstract class WeaponFactory {
  abstract createWeapon(): Weapon;
}
```

最后，我们定义具体工厂类型 SwordFactory 和 BowFactory：

```ts
class SwordFactory extends WeaponFactory {
  createWeapon() {
    return new Sword();
  }
}

class BowFactory extends WeaponFactory {
  createWeapon() {
    return new Bow();
  }
}
```

现在，我们可以使用这些类来创建武器。例如，我们可以这样创建一把剑：

```ts
const swordFactory = new SwordFactory();
const sword = swordFactory.createWeapon();
sword.use(); // Output: "Swinging sword!"
```

我们也可以这样创建一张弓：
```ts
const bowFactory = new BowFactory();
const bow = bowFactory.createWeapon();
bow.use(); // Output: "Shooting arrow!"

```